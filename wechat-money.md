#微信红包金额分配的算法

虽然春节已经过去一段时间，但不少微信群里面依旧乐此不疲的在玩发红包活动，用户自发的将最初的一个春节拜年的场景功能慢慢演化成一个长尾功能。

用户在微信中抢红包时分成抢包和拆包两个操作。抢包决定红包是否还有剩余金额，但如果行动不够迅速，在拆包阶段可能红包已经被其他用户抢走的情况。

红包的金额是在什么时候算？ 据某架构群腾讯财付通专家反馈，红包的金额是拆的时候实时计算，而不是预先分配，实时计算基于内存，不需要额外存储空间，并且实时计算效率也很高。每次拆红包时，系统取0.01到剩余平均值*2之间作为红包的金额。

为了保证每次操作的原子性，拆包过程中使用了CAS，确保每次只有一个并发用户拆包成功。拆包CAS失败的用户可以由系统自动进行重试。但也有可能在重试过程中被别的用户抢得先机而空手而归，因此严格意义拆包的调用也未能保证用户先到先得。

基于上面的原因，当时在群中提到这种算法有些复杂，微信红包为了减少存储，每次进行了一个理解稍复杂的实时计算。对比大部分架构师想到的预分配金额的做法，预先分配金额需要将金额保存在一个内存队列中，如果红包的份额较多，则需要较大的存储空间。而微信红包仅保存 count:balance 这样2个数字。count指还剩几个人可以抢，balance只还剩下的金额。

但是预分配金额也并不是非得需要额外存储。比如利用随机算法，在种子相同的情况下，随机数实际上返回的随机序列也是固定的。如以下Python代码，对于给定的seed 1024，每次执行返回的结果都是相同的。


```
>>> import random

>>> random.seed(1024)

>>> random.randint(1,100)

80

>>> random.randint(1,100)

49

>>> random.randint(1,100)

39

>>> random.randint(1,100)

83

>>> random.randint(1,100)

88

```

因此预分配金额也只需要额外存储一个种子，或利用一些红包id做加密变换做seed达到零存储。而在发放红包时候，无需进行CAS操作，而只需要对剩余红包count做一个DECR操作。当count<0时，表示红包被拆包抢完。由于DECR是原子操作，无需加锁，用简单的方法达到了先拆包先得，原理上不存在早拆包但由于并发冲突失败而抢不到红包的情况。

每个人分配的金额是：total * random(n) / random_total，不需要重复计算。
random(1)..random(n)不需要保存，因为对于给定的seed，random(1)到random(n)返回是固定的。

Reference:
1、微信红包的架构设计简介  
2、网友周航老师基于聊天记录整理的微信红包架构图（点击查看大图）

![](images/wechat/wechat-small.jpg)

##other:

>概况：2014年微信红包使用数据库硬抗整个流量，2015年使用cache抗流量。

微信的金额什么时候算？ 
答：微信金额是拆的时候实时算出来，不是预先分配的，采用的是纯内存计算，不需要预算空间存储。。 
采取实时计算金额的考虑：预算需要占存储，实时效率很高，预算才效率低。

实时性：为什么明明抢到红包，点开后发现没有？ 
答：2014年的红包一点开就知道金额，分两次操作，先抢到金额，然后再转账。 
2015年的红包的拆和抢是分离的，需要点两次，因此会出现抢到红包了，但点开后告知红包已经被领完的状况。进入到第一个页面不代表抢到，只表示当时红包还有。

分配：红包里的金额怎么算？为什么出现各个红包金额相差很大？ 
答：随机，额度在0.01和剩余平均值*2之间。 
例如：发100块钱，总共10个红包，那么平均值是10块钱一个，那么发出来的红包的额度在0.01元～20元之间波动。 
当前面3个红包总共被领了40块钱时，剩下60块钱，总共7个红包，那么这7个红包的额度在：0.01～（60/7*2）=17.14之间。 
注意：这里的算法是每被抢一个后，剩下的会再次执行上面的这样的算法（Tim老师也觉得上述算法太复杂，不知基于什么样的考虑）。

这样算下去，会超过最开始的全部金额，因此到了最后面如果不够这么算，那么会采取如下算法：保证剩余用户能拿到最低1分钱即可。

如果前面的人手气不好，那么后面的余额越多，红包额度也就越多，因此实际概率一样的。

红包的设计 
答：微信从财付通拉取金额数据郭莱，生成个数/红包类型/金额放到redis集群里，app端将红包ID的请求放入请求队列中，如果发现超过红包的个数，直接返回。根据红包的裸祭处理成功得到令牌请求，则由财付通进行一致性调用，通过像比特币一样，两边保存交易记录，交易后交给第三方服务审计，如果交易过程中出现不一致就强制回归。

发性处理：红包如何计算被抢完？ 
答：cache会抵抗无效请求，将无效的请求过滤掉，实际进入到后台的量不大。cache记录红包个数，原子操作进行个数递减，到0表示被抢光。财付通按照20万笔每秒入账准备，但实际还不到8万每秒。

通如何保持8w每秒的写入？ 
答：多主sharding，水平扩展机器。

据容量多少？ 
答：一个红包只占一条记录，有效期只有几天，因此不需要太多空间。

询红包分配，压力大不？ 
答：抢到红包的人数和红包都在一条cache记录上，没有太大的查询压力。

一个红包一个队列？ 
答：没有队列，一个红包一条数据，数据上有一个计数器字段。

有没有从数据上证明每个红包的概率是不是均等？ 
答：不是绝对均等，就是一个简单的拍脑袋算法。

拍脑袋算法，会不会出现两个最佳？ 
答：会出现金额一样的，但是手气最佳只有一个，先抢到的那个最佳。

每领一个红包就更新数据么？ 
答：每抢到一个红包，就cas更新剩余金额和红包个数。

红包如何入库入账？ 
数据库会累加已经领取的个数与金额，插入一条领取记录。入账则是后台异步操作。

入帐出错怎么办？比如红包个数没了，但余额还有？ 
答：最后会有一个take all操作。另外还有一个对账来保障。